import{flowConfig as e}from"@onflow/fcl-config";import{config as n}from"@onflow/config";import a from"fs";import t from"path";import*as r from"@onflow/fcl";import{ec as s}from"elliptic";import{SHA3 as o}from"sha3";import*as c from"rlp";import*as i from"@onflow/types";import{getEnvironment as l,reportMissingImports as d,replaceImportAddresses as g,reportMissing as u}from"flow-cadut";const p=(e,n,a)=>{if("string"==typeof n)return p(e,n.split("/"),a);if(!n.length)return e;try{const[t,...r]=n;return p(e[t],r,a)}catch(e){return a}},m=(a,t,r,s)=>{n().put(a,t||p(e(),r,s))},f=async e=>n().get(e),w=async(e,a=8080)=>{m("PRIVATE_KEY",process.env.PK,"accounts/emulator-account/keys"),m("SERVICE_ADDRESS",process.env.SERVICE_ADDRESS,"accounts/emulator-account/address","f8d6e0586b0a20c7"),n().put("accessNode.api",`http://localhost:${a}`),m("BASE_PATH",process.env.BASE_PATH,"resolve/basePath",e)};function h(){return(h=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}const A=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,M=e=>e.split(/\s/).map(e=>e.replace(/\s/g,"")).filter(e=>e.length>0&&"import"!==e&&"from"!==e),y=(e,n)=>{const[a,t]=n;return e[a]=t,e},b=e=>e&&0!==e.length?e.split("\n").filter(e=>e.includes("import")).map(M).reduce(y,{}):{},S=(e,n,a=!0)=>e.replace(A,(e,t,r,s,o)=>{const c=a?r:o;return`${t}${r} from ${n instanceof Function?n(c):n[c]}`}),T={FlowToken:"0x0ae53cb6e3f42a79",FungibleToken:"0xee82856bf20e2aa6",FlowFees:"0xe5a8b7f23e8b548f",FlowStorageFees:"0xf8d6e0586b0a20c7"},x={"0xe5a8b7f23e8b548f":"0xe5a8b7f23e8b548f","0xf8d6e0586b0a20c7":"0xf8d6e0586b0a20c7","0x0ae53cb6e3f42a79":"0x0ae53cb6e3f42a79","0xee82856bf20e2aa6":"0xee82856bf20e2aa6"},k=async(e,a="./transactions/")=>{const r=await n().get("BASE_PATH");return t.resolve(r,`${a}/${e}.cdc`)},F=(e,n={},t=!1)=>{const r=(e=>a.readFileSync(e,"utf8"))(e);return n?S(r,h({},t?x:T,n)):r},P=async({name:e,addressMap:n})=>{const a=await k(e,"./contracts/");return F(a,n)},E=async({name:e,addressMap:n})=>{const a=await k(e,"./transactions/");return F(a,n)},v=async({name:e,addressMap:n})=>{const a=await k(e,"./scripts/");return F(a,n)},R=e=>null==e?null:e.replace(/^0x/,""),C=e=>null==e?null:"0x"+R(e),B=new s("p256"),I=(e,n)=>{const a=B.keyFromPrivate(Buffer.from(e,"hex")).sign((e=>{const n=new o(256);return n.update(Buffer.from(e,"hex")),n.digest()})(n)),t=a.r.toArrayLike(Buffer,"be",32),r=a.s.toArrayLike(Buffer,"be",32);return Buffer.concat([t,r]).toString("hex")},D=(e,a=0)=>async(t={})=>{const s=await n().get("SERVICE_ADDRESS"),o=await n().get("PRIVATE_KEY");return h({},t,{tempId:`${e=R(e||s)}-${a}`,addr:r.sansPrefix(e),keyId:a,signingFunction:async n=>({keyId:a,addr:C(e),signature:I(o,n.message)})})},_=(e,n)=>{const a=e[e.length-1];return e.slice(0,-1).map(e=>n(e,a))},$=e=>e.reduce((e,n)=>[...e,..._(n,(e,n)=>r.arg(e,n))],[]),H=e=>async n=>{let a,t,r,s,o;if("object"==typeof(c=n[0])&&null!==c){const[e]=n,{name:c,addressMap:i}=e,{code:l,args:d,signers:g}=e;if(!c&&!l)throw Error("Both `name` and `code` are missing. Provide either of them");t=c,o=i||{},a=l,r=g,s=d}else{const[e,a,s]=n;t=e,r=s,o=a||{}}var c;if(t){const n="script"===e?v:E;a=await n({name:t,addressMap:o})}return{code:a,signers:r,args:s}},L=async(...e)=>{const n=H("tx"),{code:a,args:t,signers:s}=await n(e),o=D(),c=[r.transaction(a),r.payer(o),r.proposer(o),r.limit(999)];if(s){const e=s.map(e=>D(e));c.push(r.authorizations(e))}else c.push(r.authorizations([o]));t&&c.push(r.args($(t)));const i=await r.send(c);return await r.tx(i).onceExecuted()},K=async(...e)=>{const n=H("script"),{code:a,args:t}=await n(e),s=[r.script(a)];t&&s.push(r.args($(t)));const o=await r.send(s);return r.decode(o)},V="\n  pub contract FlowManager {\n\n    pub event AccountAdded(address: Address)\n\n    pub struct Mapper {\n        pub let accounts: {String: Address}\n\n        pub fun getAddress(_ name: String): Address? {\n            return self.accounts[name]\n        }\n\n        pub fun setAddress(_ name: String, address: Address){\n            self.accounts[name] = address\n            emit FlowManager.AccountAdded(address: address)\n        }\n\n        init(){\n            self.accounts = {}\n        }\n    }\n\n    pub let accountManagerStorage: StoragePath\n    pub let contractManagerStorage: StoragePath\n    pub let accountManagerPath: PublicPath\n    pub let contractManagerPath: PublicPath\n\n    init(){\n        let accountManager = Mapper()\n        let contractManager = Mapper()\n\n        self.accountManagerStorage = /storage/testSuitAccountManager\n        self.contractManagerStorage = /storage/testSuitContractManager\n\n        self.accountManagerPath = /public/testSuitAccountManager\n        self.contractManagerPath = /public/testSuitContractManager\n        \n        // Destroy previously stored values\n        self.account.load<Mapper>(from: self.accountManagerStorage)\n        self.account.load<Mapper>(from: self.contractManagerStorage)\n\n        self.account.save(accountManager, to: self.accountManagerStorage)\n        self.account.save(contractManager, to: self.contractManagerStorage)\n\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\n    }\n}\n \n",G="\n  import FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty. The script will throw error if FlowManager is not\n    // added to service address\n}\n\n",O="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.accountManagerPath\n    let accountManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return accountManager.getAddress(name)\n\n}\n",z='\n  // This script reads the balance field of an account\'s FlowToken Balance\n\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\npub fun main(account: Address): UFix64 {\n    let acct = getAccount(account)\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\n        ?? panic("Could not borrow Balance reference to the Vault")\n\n    return vaultRef.balance\n}\n',N="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.contractManagerPath\n    let contractManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return contractManager.getAddress(name)\n\n}\n",U="\n  import FlowManager from 0x01\n\ntransaction (_ name: String, pubKey: String, manager: Address) {\n    prepare( admin: AuthAccount) {\n        let newAccount = AuthAccount(payer:admin)\n        newAccount.addPublicKey(pubKey.decodeHex())\n\n        let linkPath = FlowManager.accountManagerPath\n        let accountManager = getAccount(manager)\n                            .getCapability(linkPath)!\n                            .borrow<&FlowManager.Mapper>()!\n        \n        // Create a record in account database\n        let address = newAccount.address\n        accountManager.setAddress(name, address: address)\n    }\n}\n \n",j=async(e={})=>{const n=h({},await l(),e);return d(U,n,"createAccount =>"),g(U,n)},Y=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await j(e);return u("arguments",n.length,3,Y),u("signers",a.length,1,Y),L({code:t,args:n,signers:a})},W="\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        acct.contracts.add(\n           name: name,\n           code: decoded,\n           ##ARGS-LIST##\n        )\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n",q=async(e={})=>{const n=h({},await l(),e);return d(W,n,"deployContract =>"),g(W,n)},J=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await q(e);return u("arguments",n.length,3,J),u("signers",a.length,1,J),L({code:t,args:n,signers:a})},Q='\n  transaction ( code: String ) {\n    prepare( admin: AuthAccount) {\n        admin.contracts.add(\n           name: "FlowManager",\n           code: code.decodeHex(),\n        )\n   }\n}\n\n',X=async(e={})=>{const n=h({},await l(),e);return d(Q,n,"initManager =>"),g(Q,n)},Z=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await X(e);return u("arguments",n.length,1,Z),u("signers",a.length,1,Z),L({code:t,args:n,signers:a})},ee='\n  import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic("Signer is not the token admin")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic("Unable to borrow receiver reference")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n',ne=async(e={})=>{const n=h({},await l(),e);return d(ee,n,"mintTokens =>"),g(ee,n)},ae=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await ne(e);return u("arguments",n.length,2,ae),u("signers",a.length,1,ae),L({code:t,args:n,signers:a})},te="\n  import FlowManager from 0x01\n\ntransaction(name: String, address: Address) {\n    prepare(signer: AuthAccount){\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = signer\n                                .getCapability(linkPath)!\n                                .borrow<&FlowManager.Mapper>()!\n        contractManager.setAddress(name, address: address)\n    }\n}\n",re=async(e={})=>{const n=h({},await l(),e);return d(te,n,"registerContract =>"),g(te,n)},se=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await re(e);return u("arguments",n.length,2,se),u("signers",a.length,1,se),L({code:t,args:n,signers:a})},oe="\n  transaction{\n    prepare(acct: AuthAccount){\n        log(acct.address)\n    }\n}\n",ce=async(e={})=>{const n=h({},await l(),e);return d(oe,n,"scratch =>"),g(oe,n)},ie=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await ce(e);return u("arguments",n.length,0,ie),u("signers",a.length,1,ie),L({code:t,args:n,signers:a})},le="\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",de=async(e={})=>{const n=h({},await l(),e);return d(le,n,"updateContract =>"),g(le,n)},ge=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await de(e);return u("arguments",n.length,3,ge),u("signers",a.length,1,ge),L({code:t,args:n,signers:a})};var ue={createAccount:Y,createAccountTemplate:j,deployContract:J,deployContractTemplate:q,initManager:Z,initManagerTemplate:X,mintTokens:ae,mintTokensTemplate:ne,registerContract:se,registerContractTemplate:re,scratch:ie,scratchTemplate:ce,updateContract:ge,updateContractTemplate:de},pe=ue;const me={ExampleToken:T.FlowToken},fe=e=>e[0].toLowerCase()+e.slice(1),we=async e=>{const n=await(async e=>(await(async(e={})=>{const n=h({},await l(),e);return d(z,n,"getBalance =>"),g(z,n)})(me)).replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:fe(e)))("FlowToken"),a=S(n,T);return K({code:a,args:[[e,i.Address]]})},he=async(e,n)=>{const a=await(async e=>(await pe.mintTokensTemplate(me)).replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:fe(e)))("FlowToken"),t=S(a,T);return L({code:t,args:[[e,i.Address],[n,i.UFix64]]})},Ae=async()=>C(await n().get("SERVICE_ADDRESS")),Me=async()=>{const e={FlowManager:await Ae()},n=await(async(e={})=>{const n=h({},await l(),e);return d(G,n,"checkManager =>"),g(G,n)})(e);try{await K({code:n})}catch(e){await(async()=>{const e=await pe.initManagerTemplate(),n=await(async(e={})=>{const n=h({},await l(),e);return d(V,n,"FlowManager =>"),g(V,n)})(),a=[[Te(n),i.String]];await L({code:e,args:a})})()}return Ae()},ye=async e=>{const a=e||`deployment-account-${(Math.random()*Math.pow(10,8)).toFixed(0)}`,t=await Me(),r={FlowManager:t};let s;try{const e=await(async(e={})=>{const n=h({},await l(),e);return d(O,n,"getAccountAddress =>"),g(O,n)})(r),n=[[a,i.String],[t,i.Address]];s=await K({code:e,args:n})}catch(e){console.error("failed to get account address:",e)}if(null===s)try{const e=await pe.createAccountTemplate(r),o=[[a,await(async()=>{const e=B.keyFromPrivate(Buffer.from(await n().get("PRIVATE_KEY"),"hex")).getPublic("hex").replace(/^04/,"");return c.encode([Buffer.from(e,"hex"),2,3,1e3]).toString("hex")})(),i.String],[t,i.Address]],{events:l}=await L({code:e,args:o});s=l.find(e=>e.type.includes("AccountAdded")).data.address}catch(e){console.error(e)}return s},{updateContractTemplate:be,deployContractTemplate:Se}=ue,Te=e=>Buffer.from(e,"utf8").toString("hex"),xe=async e=>{const{to:n,name:a,addressMap:t,args:r,update:s=!1}=e,o=n||await ye(),c=await P({name:a,addressMap:t});return ke({to:o,code:c,name:a,args:r,update:s})},ke=async e=>{const{to:n,code:a,name:t,args:r,update:s}=e,o=n||await ye(),c=await Ae(),l=Te(a),d={FlowManager:c};let g=s?await be(d):await Se(d),u=[[t,l,i.String],[c,i.Address]];if(r){u=u.concat(r);let e=0;const n=[],a=r.reduce((a,t)=>[...a,..._(t,(a,t)=>{const r="abcdefghijklmnopqrstuvwxyz"[e];return e+=1,n.push(r),`${r}:${t.label}`})],[]);g=g.replace("##ARGS-WITH-TYPES##",`, ${a}`),g=g.replace("##ARGS-LIST##",n)}else g=g.replace("##ARGS-WITH-TYPES##",""),g=g.replace("##ARGS-LIST##","");return L({code:g,args:u,signers:[o]})},Fe=async(e,n=!1)=>{if(n){const n=T[e];if(void 0!==n)return n}const a=await Me(),t={FlowManager:a};let r;try{const n=await(async(e={})=>{const n=h({},await l(),e);return d(N,n,"getContractAddress =>"),g(N,n)})(t),s=[[e,i.String],[a,i.Address]];r=await K({code:n,args:s})}catch(e){console.error("failed to get account address:",e)}return r},{expect:Pe}=global,Ee=async e=>"function"==typeof e?await e():await e,ve=async e=>{const n=Ee(e);return await Pe(n).resolves.not.toBe(null),await Pe(n).resolves.not.toThrow(),n.then(({status:e,errorMessage:n})=>{Pe(e).toBe(4),Pe(n).toBe("")}),n},Re=async e=>{const n=Ee(e);return await Pe(n).resolves.not.toThrow(),n},Ce=async e=>{const n=Ee(e);await Pe(n).rejects.not.toBe(null)},Be=async e=>{const n=Ee(e);await Pe(n).rejects.not.toBe(null),await Pe(n).rejects.toThrow()},{spawn:Ie}=require("child_process");var De=new class{constructor(){this.initialized=!1,this.logging=!0}setLogging(e){this.logging=e}log(e,n="log"){this.logging&&console[n](e)}async start(e=8080,n=!1){let a=e-8080+3569;return this.logging=n,this.process=Ie("flow",["emulator","-v","--http-port",e,"--port",a]),new Promise((e,n)=>{this.process.stdout.on("data",n=>{this.log(`LOG: ${n}`),n.includes("Starting HTTP server")&&(this.log("EMULATOR IS UP! Listening for events!"),this.initialized=!0,e(!0))}),this.process.stderr.on("data",e=>{this.log(`stderr: ${e}`,"error"),this.initialized=!1,n()}),this.process.on("close",n=>{this.log(`emulator exited with code ${n}`),this.initialized=!1,e(!0)})})}async stop(){return new Promise(e=>{this.process.kill(),setTimeout(()=>{this.initialized=!1,e(!0)},0)})}};export{ke as deployContract,xe as deployContractByName,De as emulator,K as executeScript,b as extractImports,ye as getAccountAddress,f as getConfigValue,Fe as getContractAddress,P as getContractCode,we as getFlowBalance,v as getScriptCode,F as getTemplate,E as getTransactionCode,w as init,he as mintFlow,Ee as promise,S as replaceImportAddresses,L as sendTransaction,m as set,ve as shallPass,Re as shallResolve,Ce as shallRevert,Be as shallThrow};
//# sourceMappingURL=index.modern.js.map

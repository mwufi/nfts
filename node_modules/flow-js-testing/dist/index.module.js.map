{"version":3,"file":"index.module.js","sources":["../src/config.js","../src/init.js","../src/imports.js","../src/file.js","../src/address.js","../src/crypto.js","../src/interaction.js","../src/generated/contracts/FlowManager.js","../src/generated/scripts/checkManager.js","../src/generated/scripts/getAccountAddress.js","../src/generated/scripts/getBalance.js","../src/generated/scripts/getContractAddress.js","../src/generated/transactions/createAccount.js","../src/generated/transactions/deployContract.js","../src/generated/transactions/initManager.js","../src/generated/transactions/mintTokens.js","../src/generated/transactions/registerContract.js","../src/generated/transactions/scratch.js","../src/generated/transactions/updateContract.js","../src/generated/transactions/index.js","../src/generated/index.js","../src/templates.js","../src/flow-token.js","../src/manager.js","../src/account.js","../src/deploy-code.js","../src/contract.js","../src/jest-asserts.js","../src/emulator.js"],"sourcesContent":["/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { flowConfig } from \"@onflow/fcl-config\";\nimport { config } from \"@onflow/config\";\n\n/**\n * Get value from provided scope and path.\n * @param scope - scope value.\n * @param path - value path in config (flow.json) file.\n * @param fallback - fallback value.\n * @returns {*} - value at specified scope and path.\n */\nexport const get = (scope, path, fallback) => {\n  if (typeof path === \"string\") return get(scope, path.split(\"/\"), fallback);\n  if (!path.length) return scope;\n  try {\n    const [head, ...rest] = path;\n    return get(scope[head], rest, fallback);\n  } catch (_error) {\n    return fallback;\n  }\n};\n\n/**\n * Set globally available config value.\n * @param {string} key - key to be used to access stored value.\n * @param {string} env - value key in the environment (for example .env file).\n * @param {string} conf - value path in config (flow.json) file.\n * @param fallback - fallback value to be used if env and conf are absent.\n */\nexport const set = (key, env, conf, fallback) => {\n  config().put(key, env || get(flowConfig(), conf, fallback));\n};\n\n/**\n * Returns config value at specified key.\n * @param key - key to the value.\n * @returns {Promise<*>} - value at specified key.\n */\nexport const getConfigValue = async (key) => {\n  return config().get(key);\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { set } from \"./config\";\nimport { config } from \"@onflow/config\";\n\n/**\n * Inits framework variables, storing private key of service account and base path\n * where Cadence files are stored.\n * @param {string} basePath - path to the folder with Cadence files to be tested.\n * @param {number} port - port to use for accessAPI\n */\nexport const init = async (basePath, port = 8080) => {\n  set(\"PRIVATE_KEY\", process.env.PK, \"accounts/emulator-account/keys\");\n  set(\n    \"SERVICE_ADDRESS\",\n    process.env.SERVICE_ADDRESS,\n    \"accounts/emulator-account/address\",\n    \"f8d6e0586b0a20c7\",\n  );\n\n  config().put(\"accessNode.api\", `http://localhost:${port}`);\n\n  set(\"BASE_PATH\", process.env.BASE_PATH, \"resolve/basePath\", basePath);\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst REGEXP_IMPORT = /(\\s*import\\s*)([\\w\\d]+)(\\s+from\\s*)([\\w\\d\".\\\\/]+)/g;\n\nconst getPairs = (line) => {\n  return line\n    .split(/\\s/)\n    .map((item) => item.replace(/\\s/g, \"\"))\n    .filter((item) => item.length > 0 && item !== \"import\" && item !== \"from\");\n};\n\nconst collect = (acc, item) => {\n  const [contract, address] = item;\n  acc[contract] = address;\n  return acc;\n};\n\n/**\n * Returns address map for contracts defined in template code.\n * @param {string} code - Cadence code to parse.\n * @returns {*}\n */\nexport const extractImports = (code) => {\n  if (!code || code.length === 0) {\n    return {};\n  }\n  return code\n    .split(\"\\n\")\n    .filter((line) => line.includes(\"import\"))\n    .map(getPairs)\n    .reduce(collect, {});\n};\n\nexport const replaceImports = (code, addressMap) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract) => {\n    const newAddress = addressMap instanceof Function ? addressMap(contract) : addressMap[contract];\n    return `${imp}${contract} from ${newAddress}`;\n  });\n};\n\n/**\n * Returns Cadence template code with replaced import addresses\n * @param {string} code - Cadence template code.\n * @param {{string:string}} [addressMap={}] - name/address map or function to use as lookup table\n * for addresses in import statements.\n * @param byName - lag to indicate whether we shall use names of the contracts.\n * @returns {*}\n */\nexport const replaceImportAddresses = (code, addressMap, byName = true) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract, _, address) => {\n    const key = byName ? contract : address;\n    const newAddress = addressMap instanceof Function ? addressMap(key) : addressMap[key];\n    return `${imp}${contract} from ${newAddress}`;\n  });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from \"fs\";\nimport path from \"path\";\nimport { config } from \"@onflow/config\";\n\nimport { replaceImportAddresses } from \"./imports\";\n\nexport const readFile = (path) => {\n  return fs.readFileSync(path, \"utf8\");\n};\n\n/**\n * Address map with access by name for contracts deployed to emulator by default.\n * @type {{FlowFees: string, FlowToken: string, FungibleToken: string}}\n */\nexport const defaultsByName = {\n  FlowToken: \"0x0ae53cb6e3f42a79\",\n  FungibleToken: \"0xee82856bf20e2aa6\",\n  FlowFees: \"0xe5a8b7f23e8b548f\",\n  FlowStorageFees: \"0xf8d6e0586b0a20c7\",\n};\n\n/**\n * Address map with access by address for contracts deployed to emulator by default.\n * @type {{\"0xe5a8b7f23e8b548f\": string, \"0xf8d6e0586b0a20c7\": string, \"0xee82856bf20e2aa6\": string, \"0x0ae53cb6e3f42a79\": string}}\n */\nexport const defaultsByAddress = {\n  \"0xe5a8b7f23e8b548f\": \"0xe5a8b7f23e8b548f\", // FlowFees\n  \"0xf8d6e0586b0a20c7\": \"0xf8d6e0586b0a20c7\", // FlowStorageFees\n  \"0x0ae53cb6e3f42a79\": \"0x0ae53cb6e3f42a79\", // FlowToken\n  \"0xee82856bf20e2aa6\": \"0xee82856bf20e2aa6\", // FungibleToken\n};\n\nconst SCRIPT = \"./scripts/\";\nconst TRANSACTION = \"./transactions/\";\nconst CONTRACT = \"./contracts/\";\n\nexport const templateType = {\n  SCRIPT,\n  TRANSACTION,\n  CONTRACT,\n};\n\nexport const getPath = async (name, type = TRANSACTION) => {\n  const configBase = await config().get(\"BASE_PATH\");\n  return path.resolve(configBase, `${type}/${name}.cdc`);\n};\n\n/**\n * Returns Cadence template for specified file. Replaces imports using provided address map\n * @param file - name of the file to look for.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [byAddress=false] - flag to indicate if address map is address to address type.\n * @returns {string}\n */\nexport const getTemplate = (file, addressMap = {}, byAddress = false) => {\n  const rawCode = readFile(file);\n\n  const defaults = byAddress ? defaultsByAddress : defaultsByName;\n\n  return addressMap\n    ? replaceImportAddresses(rawCode, {\n        ...defaults,\n        ...addressMap,\n      })\n    : rawCode;\n};\n\n/**\n * Returns contract template using name of the file in \"contracts\" folder containing the code.\n * @param name - name of the contract template in \"contract\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getContractCode = async ({ name, addressMap }) => {\n  const path = await getPath(name, templateType.CONTRACT);\n  return getTemplate(path, addressMap);\n};\n\n/**\n * Returns transaction template using name of the file in \"transactions\" folder containing the code.\n * @param name - name of the transaction template in \"transactions\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getTransactionCode = async ({ name, addressMap }) => {\n  const path = await getPath(name, templateType.TRANSACTION);\n  return getTemplate(path, addressMap);\n};\n\n/**\n * Returns script template using name of the file in \"scripts\" folder containing the code.\n * @param name - name of the script template in \"scripts\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getScriptCode = async ({ name, addressMap }) => {\n  const path = await getPath(name, templateType.SCRIPT);\n  return getTemplate(path, addressMap);\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const sansPrefix = (address) => {\n  if (address == null) return null;\n  return address.replace(/^0x/, \"\");\n};\n\nexport const withPrefix = (address) => {\n  if (address == null) return null;\n  return \"0x\" + sansPrefix(address);\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ec as EC } from \"elliptic\";\nimport { SHA3 } from \"sha3\";\nimport * as fcl from \"@onflow/fcl\";\nimport * as rlp from \"rlp\";\nimport { config } from \"@onflow/config\";\nimport { sansPrefix, withPrefix } from \"./address\";\nconst ec = new EC(\"p256\");\n\nconst hashMsgHex = (msgHex) => {\n  const sha = new SHA3(256);\n  sha.update(Buffer.from(msgHex, \"hex\"));\n  return sha.digest();\n};\n\nexport const signWithKey = (privateKey, msgHex) => {\n  const key = ec.keyFromPrivate(Buffer.from(privateKey, \"hex\"));\n  const sig = key.sign(hashMsgHex(msgHex));\n  const n = 32; // half of signature length?\n  const r = sig.r.toArrayLike(Buffer, \"be\", n);\n  const s = sig.s.toArrayLike(Buffer, \"be\", n);\n  return Buffer.concat([r, s]).toString(\"hex\");\n};\n\nexport const authorization =\n  (addr, keyId = 0) =>\n  async (account = {}) => {\n    const serviceAddress = await config().get(\"SERVICE_ADDRESS\");\n    const pkey = await config().get(\"PRIVATE_KEY\");\n\n    addr = sansPrefix(addr || serviceAddress);\n\n    const signingFunction = async (data) => ({\n      keyId,\n      addr: withPrefix(addr),\n      signature: signWithKey(pkey, data.message),\n    });\n\n    return {\n      ...account,\n      tempId: `${addr}-${keyId}`,\n      addr: fcl.sansPrefix(addr),\n      keyId,\n      signingFunction,\n    };\n  };\n\nexport const pubFlowKey = async () => {\n  const keys = ec.keyFromPrivate(Buffer.from(await config().get(\"PRIVATE_KEY\"), \"hex\"));\n  const publicKey = keys.getPublic(\"hex\").replace(/^04/, \"\");\n  return rlp\n    .encode([\n      Buffer.from(publicKey, \"hex\"), // publicKey hex to binary\n      2, // P256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      3, // SHA3-256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      1000, // give key full weight\n    ])\n    .toString(\"hex\");\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fcl from \"@onflow/fcl\";\nimport { authorization } from \"./crypto\";\nimport { getTransactionCode, getScriptCode } from \"./file\";\n\nexport const unwrap = (arr, convert) => {\n  const type = arr[arr.length - 1];\n  return arr.slice(0, -1).map((value) => convert(value, type));\n};\n\nconst mapArgs = (args) => {\n  return args.reduce((acc, arg) => {\n    const unwrapped = unwrap(arg, (value, type) => {\n      return fcl.arg(value, type);\n    });\n    acc = [...acc, ...unwrapped];\n    return acc;\n  }, []);\n};\n\nconst isObject = (arg) => typeof arg === \"object\" && arg !== null;\n\nconst extractParameters = (ixType) => {\n  return async (params) => {\n    let ixCode, ixName, ixSigners, ixArgs, ixAddressMap;\n\n    if (isObject(params[0])) {\n      const [props] = params;\n      const { name, addressMap } = props;\n      const { code, args, signers } = props;\n\n      if (!name && !code) {\n        throw Error(\"Both `name` and `code` are missing. Provide either of them\");\n      }\n      // get name and addressMap\n      ixName = name;\n      ixAddressMap = addressMap || {};\n      // or code\n      ixCode = code;\n\n      ixSigners = signers;\n      ixArgs = args;\n    } else {\n      const [name, addressMap, signers] = params;\n      ixName = name;\n      ixSigners = signers;\n      ixAddressMap = addressMap || {};\n    }\n\n    if (ixName) {\n      const getIxTemplate = ixType === \"script\" ? getScriptCode : getTransactionCode;\n      ixCode = await getIxTemplate({\n        name: ixName,\n        addressMap: ixAddressMap,\n      });\n    }\n\n    return {\n      code: ixCode,\n      signers: ixSigners,\n      args: ixArgs,\n    };\n  };\n};\n\n/**\n * Submits transaction to emulator network and waits before it will be sealed.\n * Returns transaction result.\n * @param {string} [props.name] - Name of Cadence template file\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {string} [props.code] - Cadence code of the transaction.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @param {[string]} [props.signers] - list of signers, who will authorize transaction, specified as array of addresses.\n * @returns {Promise<any>}\n */\nexport const sendTransaction = async (...props) => {\n  const extractor = extractParameters(\"tx\");\n  const { code, args, signers } = await extractor(props);\n\n  const serviceAuth = authorization();\n\n  // set repeating transaction code\n  const ix = [\n    fcl.transaction(code),\n    fcl.payer(serviceAuth),\n    fcl.proposer(serviceAuth),\n    fcl.limit(999),\n  ];\n\n  // use signers if specified\n  if (signers) {\n    const auths = signers.map((address) => authorization(address));\n    ix.push(fcl.authorizations(auths));\n  } else {\n    // and only service account if no signers\n    ix.push(fcl.authorizations([serviceAuth]));\n  }\n\n  // add arguments if any\n  if (args) {\n    ix.push(fcl.args(mapArgs(args)));\n  }\n  const response = await fcl.send(ix);\n  return await fcl.tx(response).onceExecuted();\n};\n\n/**\n * Sends script code for execution. Returns decoded value\n * @param {string} props.code - Cadence code of the script to be submitted.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @returns {Promise<*>}\n */\nexport const executeScript = async (...props) => {\n  const extractor = extractParameters(\"script\");\n  const { code, args } = await extractor(props);\n\n  const ix = [fcl.script(code)];\n  // add arguments if any\n  if (args) {\n    ix.push(fcl.args(mapArgs(args)));\n  }\n  const response = await fcl.send(ix);\n  return fcl.decode(response);\n};\n","import { deployContract } from \"../../\";\n\nimport { getEnvironment, replaceImportAddresses, reportMissingImports } from \"flow-cadut\";\n\nexport const CODE = `\n  pub contract FlowManager {\n\n    pub event AccountAdded(address: Address)\n\n    pub struct Mapper {\n        pub let accounts: {String: Address}\n\n        pub fun getAddress(_ name: String): Address? {\n            return self.accounts[name]\n        }\n\n        pub fun setAddress(_ name: String, address: Address){\n            self.accounts[name] = address\n            emit FlowManager.AccountAdded(address: address)\n        }\n\n        init(){\n            self.accounts = {}\n        }\n    }\n\n    pub let accountManagerStorage: StoragePath\n    pub let contractManagerStorage: StoragePath\n    pub let accountManagerPath: PublicPath\n    pub let contractManagerPath: PublicPath\n\n    init(){\n        let accountManager = Mapper()\n        let contractManager = Mapper()\n\n        self.accountManagerStorage = /storage/testSuitAccountManager\n        self.contractManagerStorage = /storage/testSuitContractManager\n\n        self.accountManagerPath = /public/testSuitAccountManager\n        self.contractManagerPath = /public/testSuitContractManager\n        \n        // Destroy previously stored values\n        self.account.load<Mapper>(from: self.accountManagerStorage)\n        self.account.load<Mapper>(from: self.contractManagerStorage)\n\n        self.account.save(accountManager, to: self.accountManagerStorage)\n        self.account.save(contractManager, to: self.contractManagerStorage)\n\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\n    }\n}\n \n`;\n\n/**\n * Method to generate Cadence code for FlowManager transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const FlowManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `FlowManager =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Deploys FlowManager transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * param Array<string> - list of signers\n */\nexport const FlowManager = async ({ addressMap = {}, args = [], to, update = false }) => {\n  const code = await FlowManagerTemplate(addressMap);\n  const name = \"FlowManager\";\n\n  return deployContract({ code, args, to, update, name });\n};\n","import { executeScript } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty. The script will throw error if FlowManager is not\n    // added to service address\n}\n\n`;\n\n/**\n * Method to generate cadence code for TestAsset\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const checkManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `checkManager =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const checkManager = async ({ addressMap = {}, args = [] }) => {\n  const code = await checkManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, checkManager);\n\n  return executeScript({ code, args });\n};\n","import { executeScript } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.accountManagerPath\n    let accountManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return accountManager.getAddress(name)\n\n}\n`;\n\n/**\n * Method to generate cadence code for TestAsset\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const getAccountAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getAccountAddress =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getAccountAddress = async ({ addressMap = {}, args = [] }) => {\n  const code = await getAccountAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, getAccountAddress);\n\n  return executeScript({ code, args });\n};\n","import { executeScript } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  // This script reads the balance field of an account's FlowToken Balance\n\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\npub fun main(account: Address): UFix64 {\n    let acct = getAccount(account)\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\n        ?? panic(\"Could not borrow Balance reference to the Vault\")\n\n    return vaultRef.balance\n}\n`;\n\n/**\n * Method to generate cadence code for TestAsset\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const getBalanceTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBalance =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBalance = async ({ addressMap = {}, args = [] }) => {\n  const code = await getBalanceTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, getBalance);\n\n  return executeScript({ code, args });\n};\n","import { executeScript } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.contractManagerPath\n    let contractManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return contractManager.getAddress(name)\n\n}\n`;\n\n/**\n * Method to generate cadence code for TestAsset\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const getContractAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getContractAddress =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getContractAddress = async ({ addressMap = {}, args = [] }) => {\n  const code = await getContractAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, getContractAddress);\n\n  return executeScript({ code, args });\n};\n","import { sendTransaction } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FlowManager from 0x01\n\ntransaction (_ name: String, pubKey: String, manager: Address) {\n    prepare( admin: AuthAccount) {\n        let newAccount = AuthAccount(payer:admin)\n        newAccount.addPublicKey(pubKey.decodeHex())\n\n        let linkPath = FlowManager.accountManagerPath\n        let accountManager = getAccount(manager)\n                            .getCapability(linkPath)!\n                            .borrow<&FlowManager.Mapper>()!\n        \n        // Create a record in account database\n        let address = newAccount.address\n        accountManager.setAddress(name, address: address)\n    }\n}\n \n`;\n\n/**\n * Method to generate cadence code for createAccount transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const createAccountTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `createAccount =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Sends createAccount transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * @param Array<string> - list of signers\n */\nexport const createAccount = async ({ addressMap = {}, args = [], signers = [] }) => {\n  const code = await createAccountTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, createAccount);\n  reportMissing(\"signers\", signers.length, 1, createAccount);\n\n  return sendTransaction({ code, args, signers });\n};\n","import { sendTransaction } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        acct.contracts.add(\n           name: name,\n           code: decoded,\n           ##ARGS-LIST##\n        )\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n`;\n\n/**\n * Method to generate cadence code for deployContract transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const deployContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `deployContract =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Sends deployContract transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * @param Array<string> - list of signers\n */\nexport const deployContract = async ({ addressMap = {}, args = [], signers = [] }) => {\n  const code = await deployContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, deployContract);\n  reportMissing(\"signers\", signers.length, 1, deployContract);\n\n  return sendTransaction({ code, args, signers });\n};\n","import { sendTransaction } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  transaction ( code: String ) {\n    prepare( admin: AuthAccount) {\n        admin.contracts.add(\n           name: \"FlowManager\",\n           code: code.decodeHex(),\n        )\n   }\n}\n\n`;\n\n/**\n * Method to generate cadence code for initManager transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const initManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `initManager =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Sends initManager transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * @param Array<string> - list of signers\n */\nexport const initManager = async ({ addressMap = {}, args = [], signers = [] }) => {\n  const code = await initManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, initManager);\n  reportMissing(\"signers\", signers.length, 1, initManager);\n\n  return sendTransaction({ code, args, signers });\n};\n","import { sendTransaction } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n`;\n\n/**\n * Method to generate cadence code for mintTokens transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const mintTokensTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `mintTokens =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Sends mintTokens transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * @param Array<string> - list of signers\n */\nexport const mintTokens = async ({ addressMap = {}, args = [], signers = [] }) => {\n  const code = await mintTokensTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, mintTokens);\n  reportMissing(\"signers\", signers.length, 1, mintTokens);\n\n  return sendTransaction({ code, args, signers });\n};\n","import { sendTransaction } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FlowManager from 0x01\n\ntransaction(name: String, address: Address) {\n    prepare(signer: AuthAccount){\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = signer\n                                .getCapability(linkPath)!\n                                .borrow<&FlowManager.Mapper>()!\n        contractManager.setAddress(name, address: address)\n    }\n}\n`;\n\n/**\n * Method to generate cadence code for registerContract transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const registerContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `registerContract =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Sends registerContract transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * @param Array<string> - list of signers\n */\nexport const registerContract = async ({ addressMap = {}, args = [], signers = [] }) => {\n  const code = await registerContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, registerContract);\n  reportMissing(\"signers\", signers.length, 1, registerContract);\n\n  return sendTransaction({ code, args, signers });\n};\n","import { sendTransaction } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  transaction{\n    prepare(acct: AuthAccount){\n        log(acct.address)\n    }\n}\n`;\n\n/**\n * Method to generate cadence code for scratch transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const scratchTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `scratch =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Sends scratch transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * @param Array<string> - list of signers\n */\nexport const scratch = async ({ addressMap = {}, args = [], signers = [] }) => {\n  const code = await scratchTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, scratch);\n  reportMissing(\"signers\", signers.length, 1, scratch);\n\n  return sendTransaction({ code, args, signers });\n};\n","import { sendTransaction } from \"../../\";\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n} from \"flow-cadut\";\n\nexport const CODE = `\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n`;\n\n/**\n * Method to generate cadence code for updateContract transaction\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const updateContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n    ...envMap,\n    ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `updateContract =>`);\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n/**\n * Sends updateContract transaction to the network\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param Array<*> args - list of arguments\n * @param Array<string> - list of signers\n */\nexport const updateContract = async ({ addressMap = {}, args = [], signers = [] }) => {\n  const code = await updateContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, updateContract);\n  reportMissing(\"signers\", signers.length, 1, updateContract);\n\n  return sendTransaction({ code, args, signers });\n};\n","import { createAccountTemplate, createAccount } from \"./createAccount\";\nimport { deployContractTemplate, deployContract } from \"./deployContract\";\nimport { initManagerTemplate, initManager } from \"./initManager\";\nimport { mintTokensTemplate, mintTokens } from \"./mintTokens\";\nimport { registerContractTemplate, registerContract } from \"./registerContract\";\nimport { scratchTemplate, scratch } from \"./scratch\";\nimport { updateContractTemplate, updateContract } from \"./updateContract\";\n\nexport default {\n  createAccount,\n  createAccountTemplate,\n  deployContract,\n  deployContractTemplate,\n  initManager,\n  initManagerTemplate,\n  mintTokens,\n  mintTokensTemplate,\n  registerContract,\n  registerContractTemplate,\n  scratch,\n  scratchTemplate,\n  updateContract,\n  updateContractTemplate,\n};\n","import contracts from \"./contracts\";\nimport scripts from \"./scripts\";\nimport transactions from \"./transactions\";\n\nexport default {\n  contracts,\n  scripts,\n  transactions,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport registry from \"./generated\";\nimport { defaultsByName } from \"./file\";\n\nconst FlowTokenMap = { ExampleToken: defaultsByName.FlowToken };\n\nconst lowerFirst = (name) => {\n  return name[0].toLowerCase() + name.slice(1);\n};\n\nexport const makeMintTransaction = async (name) => {\n  const code = await registry.transactions.mintTokensTemplate(FlowTokenMap);\n  const pattern = /(ExampleToken)/gi;\n\n  return code.replace(pattern, (match) => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name);\n  });\n};\n\nexport const makeGetBalance = async (name) => {\n  const code = await registry.scripts.getBalanceTemplate(FlowTokenMap);\n  const pattern = /(ExampleToken)/gi;\n\n  return code.replace(pattern, (match) => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name);\n  });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as types from \"@onflow/types\";\nimport { defaultsByName } from \"./file\";\nimport { replaceImportAddresses } from \"./imports\";\nimport { executeScript, sendTransaction } from \"./interaction\";\nimport { makeGetBalance, makeMintTransaction } from \"./templates\";\n\n/**\n * Returns current FlowToken balance of account specified by address\n * @param {string} address - address of account to check\n * @returns {Promise<*>}\n */\nexport const getFlowBalance = async (address) => {\n  const raw = await makeGetBalance(\"FlowToken\");\n  const code = replaceImportAddresses(raw, defaultsByName);\n  const args = [[address, types.Address]];\n\n  return executeScript({ code, args });\n};\n\n/**\n * Sends transaction to mint specified amount of FlowToken and send it to recipient.\n * Returns result of the transaction.\n * @param {string} recipient - address of recipient account\n * @param {string} amount - amount to mint and send\n * @returns {Promise<*>}\n */\nexport const mintFlow = async (recipient, amount) => {\n  const raw = await makeMintTransaction(\"FlowToken\");\n  const code = replaceImportAddresses(raw, defaultsByName);\n  const args = [\n    [recipient, types.Address],\n    [amount, types.UFix64],\n  ];\n\n  return sendTransaction({ code, args });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as t from \"@onflow/types\";\nimport { executeScript, sendTransaction } from \"./interaction\";\nimport { config } from \"@onflow/config\";\nimport { withPrefix } from \"./address\";\nimport { hexContract } from \"./deploy-code\";\nimport registry from \"./generated\";\n\nexport const initManager = async () => {\n  const code = await registry.transactions.initManagerTemplate();\n  const contractCode = await registry.contracts.FlowManagerTemplate();\n  const hexedContract = hexContract(contractCode);\n  const args = [[hexedContract, t.String]];\n\n  await sendTransaction({\n    code,\n    args,\n  });\n};\n\nexport const getServiceAddress = async () => {\n  return withPrefix(await config().get(\"SERVICE_ADDRESS\"));\n};\n\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress();\n\n  const addressMap = {\n    FlowManager: serviceAddress,\n  };\n\n  const code = await registry.scripts.checkManagerTemplate(addressMap);\n\n  try {\n    await executeScript({\n      code,\n    });\n  } catch (e) {\n    await initManager();\n  }\n\n  return getServiceAddress();\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as t from \"@onflow/types\";\n\nimport { pubFlowKey } from \"./crypto\";\nimport { executeScript, sendTransaction } from \"./interaction\";\nimport { getManagerAddress } from \"./manager\";\n\nimport registry from \"./generated\";\n\n/**\n * Returns address of account specified by name. If account with that name doesn't exist it will be created\n * and assigned provided name as alias\n * @param {string} accountName - name of the account\n * @returns {Promise<string|*>}\n */\nexport const getAccountAddress = async (accountName) => {\n  const name = accountName || `deployment-account-${(Math.random() * Math.pow(10, 8)).toFixed(0)}`;\n\n  const managerAddress = await getManagerAddress();\n\n  const addressMap = {\n    FlowManager: managerAddress,\n  };\n\n  let accountAddress;\n  try {\n    const code = await registry.scripts.getAccountAddressTemplate(addressMap);\n\n    const args = [\n      [name, t.String],\n      [managerAddress, t.Address],\n    ];\n    accountAddress = await executeScript({\n      code,\n      args,\n    });\n  } catch (e) {\n    console.error(\"failed to get account address:\", e);\n  }\n\n  if (accountAddress === null) {\n    try {\n      const code = await registry.transactions.createAccountTemplate(addressMap);\n      const publicKey = await pubFlowKey();\n      const args = [\n        [name, publicKey, t.String],\n        [managerAddress, t.Address],\n      ];\n      const { events } = await sendTransaction({\n        code,\n        args,\n      });\n      const event = events.find((event) => event.type.includes(\"AccountAdded\"));\n      accountAddress = event.data.address;\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  return accountAddress;\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as t from \"@onflow/types\";\nimport { unwrap, sendTransaction } from \"./interaction\";\nimport { getServiceAddress } from \"./manager\";\nimport { getContractCode } from \"./file\";\nimport { getAccountAddress } from \"./account\";\n\nimport txRegistry from \"./generated/transactions\";\nconst { updateContractTemplate, deployContractTemplate } = txRegistry;\n\nexport const hexContract = (contract) => Buffer.from(contract, \"utf8\").toString(\"hex\");\n\n/**\n * Deploys a contract by name to specified account\n * Returns transaction result.\n * @param {string} props.to - If no address is supplied, the contract will be deployed to the emulator service account.\n * @param {string} props.name  - The name of the contract to look for. This should match a .cdc file located at the specified `basePath`.\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced.\n * @returns {Promise<any>}\n */\nexport const deployContractByName = async (props) => {\n  const { to, name, addressMap, args, update = false } = props;\n\n  const resolvedAddress = to || (await getAccountAddress());\n  const contractCode = await getContractCode({ name, addressMap });\n\n  return deployContract({\n    to: resolvedAddress,\n    code: contractCode,\n    name,\n    args,\n    update,\n  });\n};\n\n/**\n * Deploys contract as Cadence code to specified account\n * Returns transaction result.\n * @param {string} props.code - Cadence code for contract to be deployed\n * @param {string} props.to - If no address is supplied, the contract\n * will be deployed to the emulator service account\n * @param {string} props.name  - The name of the contract to look for. This should match\n * a .cdc file located at the specified `basePath`\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced\n */\nexport const deployContract = async (props) => {\n  const { to, code: contractCode, name, args, update } = props;\n\n  // TODO: extract name from contract code\n  const containerAddress = to || (await getAccountAddress());\n  const managerAddress = await getServiceAddress();\n  const hexedCode = hexContract(contractCode);\n  const addressMap = {\n    FlowManager: managerAddress,\n  };\n\n  let code = update\n    ? await updateContractTemplate(addressMap)\n    : await deployContractTemplate(addressMap);\n\n  let deployArgs = [\n    [name, hexedCode, t.String],\n    [managerAddress, t.Address],\n  ];\n\n  // We don't really care about the names of the arguments, but we need unique one for each one of them\n  const argLetter = \"abcdefghijklmnopqrstuvwxyz\";\n  if (args) {\n    deployArgs = deployArgs.concat(args);\n\n    let i = 0;\n    const argsList = [];\n    const argsWithTypes = args.reduce((acc, arg) => {\n      const unwrapped = unwrap(arg, (value, type) => {\n        const argName = argLetter[i];\n        i += 1;\n        argsList.push(argName);\n        return `${argName}:${type.label}`;\n      });\n      acc = [...acc, ...unwrapped];\n      return acc;\n    }, []);\n\n    code = code.replace(\"##ARGS-WITH-TYPES##\", `, ${argsWithTypes}`);\n    code = code.replace(\"##ARGS-LIST##\", argsList);\n  } else {\n    code = code.replace(\"##ARGS-WITH-TYPES##\", ``);\n    code = code.replace(\"##ARGS-LIST##\", \"\");\n  }\n\n  const signers = [containerAddress];\n\n  return sendTransaction({\n    code,\n    args: deployArgs,\n    signers,\n  });\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as t from \"@onflow/types\";\nimport { getManagerAddress } from \"./manager\";\nimport { executeScript } from \"./interaction\";\nimport { defaultsByName } from \"./file\";\n\nimport registry from \"./generated\";\n\n/**\n * Returns address of the account where contract specified by name is currently deployed\n * @param {string} name - name of the account to look for\n * @param {boolean} [useDefaults=false] - whether we shall look into default addressed first\n * @returns {Promise<string>}\n */\nexport const getContractAddress = async (name, useDefaults = false) => {\n  // TODO: Maybe try to automatically deploy contract? \n\n  if (useDefaults) {\n    const defaultContract = defaultsByName[name];\n    if (defaultContract !== undefined) {\n      return defaultContract;\n    }\n  }\n\n  const managerAddress = await getManagerAddress();\n\n  const addressMap = {\n    FlowManager: managerAddress,\n  };\n\n  let contractAddress;\n  try {\n    const code = await registry.scripts.getContractAddressTemplate(addressMap);\n    const args = [\n      [name, t.String],\n      [managerAddress, t.Address],\n    ];\n    contractAddress = await executeScript({\n      code,\n      args,\n    });\n  } catch (e) {\n    console.error(\"failed to get account address:\", e);\n  }\n\n  return contractAddress;\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { expect } = global;\n\n/**\n * Return Promise from passed interaction\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*>\n * */\nexport const promise = async (ix) => {\n  if (typeof ix === \"function\") {\n    return await ix();\n  }\n  return await ix;\n};\n\n/**\n * Ensure transaction did not throw and sealed.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - transaction result\n * */\nexport const shallPass = async (ix) => {\n  const wrappedInteraction = promise(ix);\n  await expect(wrappedInteraction).resolves.not.toBe(null);\n  await expect(wrappedInteraction).resolves.not.toThrow();\n\n  wrappedInteraction.then(({ status, errorMessage }) => {\n    expect(status).toBe(4);\n    expect(errorMessage).toBe(\"\");\n  });\n\n  return wrappedInteraction;\n};\n\n/**\n * Ensure interaction did not throw and return result of it\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - result of interaction\n * */\nexport const shallResolve = async (ix) => {\n  const wrappedInteraction = promise(ix);\n  await expect(wrappedInteraction).resolves.not.toThrow();\n\n  return wrappedInteraction;\n};\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallRevert = async (ix) => {\n  const wrappedInteraction = promise(ix);\n  await expect(wrappedInteraction).rejects.not.toBe(null);\n};\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallThrow = async (ix) => {\n  const wrappedInteraction = promise(ix);\n  await expect(wrappedInteraction).rejects.not.toBe(null);\n  await expect(wrappedInteraction).rejects.toThrow();\n};","/*\n * Flow JS Testing\n *\n * Copyright 2020 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { spawn } = require(\"child_process\");\n\nconst DEFAULT_HTTP_PORT = 8080;\nconst DEFAULT_GRPC_PORT = 3569;\n\n/** Class representing emulator */\nclass Emulator {\n  /**\n   * Create an emulator.\n   */\n  constructor() {\n    this.initialized = false;\n    this.logging = true;\n  }\n\n  /**\n   * Set logging flag.\n   * @param {boolean} logging - whether logs shall be printed\n   */\n  setLogging(logging) {\n    this.logging = logging;\n  }\n\n  /**\n   * Log message with a specific type.\n   * @param {*} message - message to put into log output\n   * @param {\"log\"|\"error\"} type - type of the message to output\n   */\n  log(message, type = \"log\") {\n    this.logging && console[type](message);\n  }\n\n  /**\n   * Start emulator.\n   * @param {number} port - port to use for accessApi\n   * @param {boolean} logging - whether logs shall be printed\n   * @returns Promise<*>\n   */\n  async start(port = DEFAULT_HTTP_PORT, logging = false) {\n    const offset = port - DEFAULT_HTTP_PORT;\n    let grpc = DEFAULT_GRPC_PORT + offset;\n\n    this.logging = logging;\n    this.process = spawn(\"flow\", [\"emulator\", \"-v\", \"--http-port\", port, \"--port\", grpc]);\n\n    return new Promise((resolve, reject) => {\n      this.process.stdout.on(\"data\", (data) => {\n        this.log(`LOG: ${data}`);\n        if (data.includes(\"Starting HTTP server\")) {\n          this.log(\"EMULATOR IS UP! Listening for events!\");\n          this.initialized = true;\n          resolve(true);\n        }\n      });\n\n      this.process.stderr.on(\"data\", (data) => {\n        this.log(`stderr: ${data}`, \"error\");\n        this.initialized = false;\n        reject();\n      });\n\n      this.process.on(\"close\", (code) => {\n        this.log(`emulator exited with code ${code}`);\n        this.initialized = false;\n        resolve(true)\n      });\n    });\n  }\n\n  /**\n   * Stop emulator.\n   * @returns Promise<*>\n   */\n  async stop() {\n    // eslint-disable-next-line no-undef\n    return new Promise((resolve) => {\n      this.process.kill();\n      setTimeout(() => {\n        this.initialized = false;\n        resolve(true);\n      }, 0);\n    });\n  }\n}\n\n/** Singleton instance */\nexport default new Emulator();\n"],"names":["get","scope","path","fallback","split","length","head","rest","_error","set","key","env","conf","config","put","flowConfig","getConfigValue","init","basePath","port","process","PK","SERVICE_ADDRESS","BASE_PATH","REGEXP_IMPORT","getPairs","line","map","item","replace","filter","collect","acc","extractImports","code","includes","reduce","replaceImportAddresses","addressMap","byName","match","imp","contract","_","address","Function","defaultsByName","FlowToken","FungibleToken","FlowFees","FlowStorageFees","defaultsByAddress","0xe5a8b7f23e8b548f","0xf8d6e0586b0a20c7","0x0ae53cb6e3f42a79","0xee82856bf20e2aa6","getPath","name","type","configBase","resolve","getTemplate","file","byAddress","rawCode","fs","readFileSync","readFile","getContractCode","getTransactionCode","getScriptCode","sansPrefix","withPrefix","ec","EC","authorization","addr","keyId","account","serviceAddress","pkey","tempId","fcl","signingFunction","data","signature","privateKey","msgHex","message","sig","keyFromPrivate","Buffer","from","sign","sha","SHA3","update","digest","hashMsgHex","r","toArrayLike","s","concat","toString","unwrap","arr","convert","slice","value","mapArgs","args","arg","unwrapped","extractParameters","ixType","params","ixCode","ixName","ixSigners","ixArgs","ixAddressMap","signers","props","Error","sendTransaction","extractor","serviceAuth","ix","transaction","payer","proposer","limit","auths","push","authorizations","send","response","tx","onceExecuted","executeScript","script","decode","CODE","createAccountTemplate","getEnvironment","envMap","fullMap","reportMissingImports","deployContractTemplate","initManagerTemplate","mintTokensTemplate","registerContractTemplate","scratchTemplate","updateContractTemplate","createAccount","reportMissing","deployContract","initManager","mintTokens","registerContract","scratch","updateContract","transactions","FlowTokenMap","ExampleToken","lowerFirst","toLowerCase","getFlowBalance","registry","makeGetBalance","raw","types","Address","mintFlow","recipient","amount","makeMintTransaction","UFix64","getServiceAddress","getManagerAddress","FlowManager","body","recover","result","e","then","contractCode","hexedContract","hexContract","t","String","getAccountAddress","accountName","Math","random","pow","toFixed","managerAddress","accountAddress","_Buffer2","publicKey","getPublic","rlp","encode","pubFlowKey","event","events","find","console","error","txRegistry","deployContractByName","resolvedAddress","to","containerAddress","hexedCode","deployArgs","i","argsList","argsWithTypes","argName","label","getContractAddress","useDefaults","defaultContract","undefined","contractAddress","expect","global","promise","shallPass","wrappedInteraction","resolves","not","toBe","toThrow","errorMessage","status","shallResolve","shallRevert","rejects","shallThrow","spawn","require","this","initialized","logging","setLogging","log","start","grpc","_this2","Promise","reject","stdout","on","stderr","stop","_this4","kill","setTimeout"],"mappings":"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"}
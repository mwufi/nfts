import{config as e}from"@onflow/config";import{invariant as t}from"@onflow/util-invariant";import{Transaction as n,SendTransactionRequest as a,AccessAPI as r,GetTransactionRequest as o,ExecuteScriptAtBlockIDRequest as s,ExecuteScriptAtBlockHeightRequest as c,ExecuteScriptAtLatestBlockRequest as i,GetAccountAtBlockHeightRequest as u,GetAccountAtLatestBlockRequest as l,GetEventsForHeightRangeRequest as d,GetEventsForBlockIDsRequest as g,GetLatestBlockRequest as p,GetBlockByIDRequest as f,GetBlockByHeightRequest as m,PingRequest as y}from"@onflow/protobuf";import{sansPrefix as h,withPrefix as k}from"@onflow/util-address";import{grpc as I}from"@improbable-eng/grpc-web";import{NodeHttpTransport as w}from"@improbable-eng/grpc-web-node-http-transport";import{encode as b}from"@onflow/rlp";import{template as S}from"@onflow/util-template";export{template as cadence,template as cdc}from"@onflow/util-template";function v(){return(v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const B='{\n  "tag":"UNKNOWN",\n  "assigns":{},\n  "status":"OK",\n  "reason":null,\n  "accounts":{},\n  "params":{},\n  "arguments":{},\n  "message": {\n    "cadence":null,\n    "refBlock":null,\n    "computLimit":null,\n    "proposer":null,\n    "payer":null,\n    "authorizations":[],\n    "params":[],\n    "arguments":[]\n  },\n  "proposer":null,\n  "authorizations":[],\n  "payer":null,\n  "events": {\n    "eventType":null,\n    "start":null,\n    "end":null,\n    "blockIds":[]\n  },\n  "transaction": {\n    "id":null\n  },\n  "block": {\n    "id":null,\n    "height":null,\n    "isSealed":null\n  },\n  "account": {\n    "addr":null\n  }\n}',A=new Set(Object.keys(JSON.parse(B))),T=()=>JSON.parse(B),N=e=>null==e,x="abcdefghijklmnopqrstuvwxyz0123456789".split(""),E=()=>x[~~(Math.random()*x.length)],O=()=>Array.from({length:10},E).join(""),L=e=>(e.status="OK",e),_=(e,t)=>(e.status="BAD",e.reason=t,e),U=e=>t=>(t.tag=e,L(t)),C=(e,t)=>n=>(n.accounts[t]=JSON.parse('{\n  "kind":"ACCOUNT",\n  "tempId":null,\n  "addr":null,\n  "keyId":null,\n  "sequenceNum":null,\n  "signature":null,\n  "signingFunction":null,\n  "resolve":null,\n  "role": {\n    "proposer":false,\n    "authorizer":false,\n    "payer":false,\n    "param":false\n  }\n}'),n.accounts[t].tempId=t,n.accounts[t].addr=e.addr,n.accounts[t].keyId=e.keyId,n.accounts[t].sequenceNum=e.sequenceNum,n.accounts[t].signature=e.signature,n.accounts[t].signingFunction=e.signingFunction,n.accounts[t].resolve=e.resolve,n.accounts[t].role=v({},n.accounts[t].role,e.role),L(n)),K=e=>t=>{let n=O();return t.message.params.push(n),t.params[n]=JSON.parse('{\n  "kind":"PARAM",\n  "tempId":null,\n  "key":null,\n  "value":null,\n  "asParam":null,\n  "xform":null,\n  "resolve": null\n}'),t.params[n].tempId=n,t.params[n].key=e.key,t.params[n].value=e.value,t.params[n].asParam=e.asParam,t.params[n].xform=e.xform,t.params[n].resolve=e.resolve,L(t)},R=e=>t=>{let n=O();return t.message.arguments.push(n),t.arguments[n]=JSON.parse('{\n  "kind":"ARGUMENT",\n  "tempId":null,\n  "value":null,\n  "asArgument":null,\n  "xform":null,\n  "resolve": null\n}'),t.arguments[n].tempId=n,t.arguments[n].value=e.value,t.arguments[n].asArgument=e.asArgument,t.arguments[n].xform=e.xform,t.arguments[n].resolve=e.resolve,L(t)},D=U("SCRIPT"),G=U("TRANSACTION"),P=U("GET_TRANSACTION_STATUS"),j=U("GET_TRANSACTION"),z=U("GET_ACCOUNT"),F=U("GET_EVENTS"),H=U("GET_LATEST_BLOCK"),q=U("GET_BLOCK_BY_ID"),J=U("GET_BLOCK_BY_HEIGHT"),$=U("PING"),W=U("GET_BLOCK"),Y=U("GET_BLOCK_HEADER"),M=e=>t=>t.tag===e,V=M("UNKNOWN"),X=M("SCRIPT"),Q=M("TRANSACTION"),Z=M("GET_TRANSACTION_STATUS"),ee=M("GET_TRANSACTION"),te=M("GET_ACCOUNT"),ne=M("GET_EVENTS"),ae=M("GET_LATEST_BLOCK"),re=M("GET_BLOCK_BY_ID"),oe=M("GET_BLOCK_BY_HEIGHT"),se=M("PING"),ce=M("GET_BLOCK"),ie=M("GET_BLOCK_HEADER"),ue=e=>"OK"===e.status,le=e=>"BAD"===e.status,de=e=>e.reason,ge=async(e,t=[])=>{try{if(e=(e=>{for(let t of Object.keys(e))if(!A.has(t))throw new Error(`"${t}" is an invalid root level Interaction property.`);return e})(await e),le(e))throw new Error("Interaction Error: "+e.reason);if(!t.length)return e;const[n,...a]=t,r=await n;if("function"==typeof r)return ge(r(e),a);if(N(r)||!r)return ge(e,a);if((e=>{if("object"!=typeof e||N(e)||(e=>"number"===e)(e))return!1;for(let t of A)if(!e.hasOwnProperty(t))return!1;return!0})(r))return ge(r,a);throw new Error("Invalid Interaction Composition")}catch(e){throw e}},pe=(...e)=>{const[t,n]=e;return Array.isArray(t)&&null==n?e=>pe(e,t):ge(t,n)},fe=e=>e,me=(e,t,n)=>null==e.assigns[t]?n:e.assigns[t],ye=(e,t)=>n=>(n.assigns[e]=t,L(n)),he=(e,t=fe)=>n=>(n.assigns[e]=t(n.assigns[e],n),L(n)),ke=e=>t=>(delete t.assigns[e],L(t));function Ie(e=[]){return pe(T(),e)}const we=()=>JSON.parse('{"tag": 0, "transaction":null, "transactionId":null, "encodedData":null, "events": null, "account": null}');async function be(e,t,n){return new Promise((a,r)=>{I.unary(t,{request:n,host:e,onEnd:({status:e,statusMessage:t,message:n})=>{e===I.Code.OK?a(n):r(new Error(t))}})})}I.setDefaultTransport(w());const Se=e=>Buffer.from(e,"hex"),ve=e=>Buffer.from(e.padStart(16,0),"hex"),Be=e=>Buffer.from(e).toString("hex"),Ae=e=>Buffer.from(e).toString("hex"),Te=e=>Buffer.from(e).toString("hex"),Ne=e=>Buffer.from(e).toString("hex"),xe=e=>Buffer.from(e).toString("hex"),Ee=async(t,I={})=>{switch(I.node=I.node||await e().get("accessNode.api"),t=await t,!0){case Q(t):return async function(e,t={}){e=await e;const o=new n;o.setScript((e=>Buffer.from(e,"utf8"))(e.message.cadence)),o.setGasLimit(e.message.computeLimit),o.setReferenceBlockId(e.message.refBlock?Se(e.message.refBlock):null),o.setPayer(ve(h(e.accounts[e.payer].addr))),e.message.arguments.forEach(t=>o.addArguments((e=>Buffer.from(JSON.stringify(e),"utf8"))(e.arguments[t].asArgument))),e.authorizations.map(t=>e.accounts[t].addr).reduce((e,t)=>e.find(e=>e===t)?e:[...e,t],[]).forEach(e=>o.addAuthorizers(ve(h(e))));const s=new n.ProposalKey;s.setAddress(ve(h(e.accounts[e.proposer].addr))),s.setKeyId(e.accounts[e.proposer].keyId),s.setSequenceNumber(e.accounts[e.proposer].sequenceNum),o.setProposalKey(s);for(let t of Object.values(e.accounts))try{if(!t.role.payer&&null!=t.signature){const e=new n.Signature;e.setAddress(ve(h(t.addr))),e.setKeyId(t.keyId),e.setSignature(Se(t.signature)),o.addPayloadSignatures(e)}}catch(n){throw console.error("Trouble applying payload signature",{acct:t,ix:e}),n}for(let t of Object.values(e.accounts))try{if(t.role.payer&&null!=t.signature){const e=new n.Signature;e.setAddress(ve(h(t.addr))),e.setKeyId(t.keyId),e.setSignature(Se(t.signature)),o.addEnvelopeSignatures(e)}}catch(n){throw console.error("Trouble applying envelope signature",{acct:t,ix:e}),n}const c=new a;c.setTransaction(o);var i=Date.now();const u=await be(t.node,r.SendTransaction,c);var l=Date.now();let d=we();var g;return d.tag=e.tag,d.transactionId=(g=u.getId_asU8(),Buffer.from(g).toString("hex")),"undefined"!=typeof window&&window.dispatchEvent(new CustomEvent("FLOW::TX",{detail:{txId:d.transactionId,delta:l-i}})),d}(t,I);case Z(t):return async function(e,t={}){e=await e;const n=new o;n.setId(Buffer.from(e.transaction.id,"hex"));const a=await be(t.node,r.GetTransactionResult,n);let s=a.getEventsList(),c=we();return c.tag=e.tag,c.transaction={status:a.getStatus(),statusCode:a.getStatusCode(),errorMessage:a.getErrorMessage(),events:s.map(e=>{return{type:e.getType(),transactionId:(t=e.getTransactionId_asU8(),Buffer.from(t).toString("hex")),transactionIndex:e.getTransactionIndex(),eventIndex:e.getEventIndex(),payload:JSON.parse(Buffer.from(e.getPayload_asU8()).toString("utf8"))};var t})},c}(t,I);case ee(t):return async function(e,t={}){e=await e;const n=new o;n.setId(Buffer.from(e.transaction.id,"hex")),(await be(t.node,r.GetTransaction,n)).getEventsList();let a=we();a.tag=e.tag;const s=e=>({address:Be(key.getAddress_asU8()),keyId:key.getKeyId(),signature:Be(key.getSequenceNumber_asU8())});let c=a.getTransaction();return a.transaction={script:Be(c.getScript_asU8()),arguments:c.getArgumentsList().map(Be),referenceBlockId:Be(c.getReferenceBlockId_asU8()),gasLimit:c.getGasLimit(),proposalKey:(e=>({address:Be(e.getAddress_asU8()),keyId:e.getKeyId(),sequenceNumber:e.getSequenceNumber()}))(c.getProposalKey()),payer:Be(c.getPayer_asU8()),authorizers:c.getAuthorizersList().map(Be),payloadSignatures:c.getPayloadSignaturesList().map(s),envelopeSignatures:c.getEnvelopeSignaturesList().map(s)},a}(t,I);case X(t):return async function(e,t={}){let n;(e=await e).block.id?(n=new s,n.setBlockId(Buffer.from(e.block.id,"hex"))):e.block.height?(n=new c,n.setBlockHeight(Number(e.block.height))):n=new i;const a=Buffer.from(e.message.cadence,"utf8");e.message.arguments.forEach(t=>n.addArguments((e=>Buffer.from(JSON.stringify(e),"utf8"))(e.arguments[t].asArgument))),n.setScript(a);const o=await be(t.node,r.ExecuteScriptAtLatestBlock,n);let u=we();return u.tag=e.tag,u.encodedData=JSON.parse(Buffer.from(o.getValue_asU8()).toString("utf8")),u}(t,I);case te(t):return async function(e,t={}){const n=(e=await e).block.height?new u:new l;var a;e.block.height&&n.setHeight(Number(e.block.height)),n.setAddress((a=h(e.account.addr),Buffer.from(a.padStart(16,0),"hex")));const o=await be(t.node,r.GetAccount,n);let s=we();s.tag=e.tag;const c=o.getAccount();let i;const d=(i=c.getContractsMap())?i.getEntryList().reduce((e,t)=>v({},e,{[t[0]]:new TextDecoder("utf-8").decode(t[1]||new UInt8Array)}),{}):{};return s.account={address:k(Ae(c.getAddress_asU8())),balance:c.getBalance(),code:new TextDecoder("utf-8").decode(c.getCode_asU8()||new UInt8Array),contracts:d,keys:c.getKeysList().map(e=>({index:e.getIndex(),publicKey:Ae(e.getPublicKey_asU8()),signAlgo:e.getSignAlgo(),hashAlgo:e.getHashAlgo(),weight:e.getWeight(),sequenceNumber:e.getSequenceNumber(),revoked:e.getRevoked()}))},s}(t,I);case ne(t):return async function(e,t={}){const n=(e=await e).events.start?new d:new g;n.setType(e.events.eventType),e.events.start?(n.setStartHeight(Number(e.events.start)),n.setEndHeight(Number(e.events.end))):e.events.blockIds.forEach(e=>n.addBlockIds(Buffer.from(e,"hex")));const a=await be(t.node,r.GetEventsForHeightRange,n);let o=we();o.tag=e.tag;const s=a.getResultsList();return o.events=s.reduce((e,t)=>{const n=t.getBlockId(),a=t.getBlockHeight(),r=t.getBlockTimestamp();return t.getEventsList().forEach(t=>{var o;e.push({blockId:n,blockHeight:a,blockTimestamp:r,type:t.getType(),transactionId:(o=t.getTransactionId_asU8(),Buffer.from(o).toString("hex")),transactionIndex:t.getTransactionIndex(),eventIndex:t.getEventIndex(),payload:JSON.parse(Buffer.from(t.getPayload_asU8()).toString("utf8"))})}),e},[]),o}(t,I);case ae(t):case ce(t):return async function(e,t={}){e=await e;const n=new p;e.latestBlock&&e.latestBlock.isSealed&&(n.setIsSealed(e.latestBlock.isSealed),console.error("\n          %c@onflow/send Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the interaction object is deprecated and will no longer be recognized in future releases of @onflow/send.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/send/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;")),e.block&&e.block.isSealed&&n.setIsSealed(e.block.isSealed);const a=(await be(t.node,r.GetLatestBlock,n)).getBlock(),o=a.getCollectionGuaranteesList(),s=a.getBlockSealsList(),c=a.getSignaturesList(),i=we();return i.tag=e.tag,i.block={id:Te(a.getId_asU8()),parentId:Te(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:o.map(e=>({collectionId:Te(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:s.map(e=>({blockId:Te(e.getBlockId_asU8()),executionReceiptId:Te(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:c},i}(t,I);case re(t):return async function(e,t={}){e=await e;const n=new f;n.setId(Buffer.from(e.block.id,"hex"));const a=(await be(t.node,r.GetBlockByID,n)).getBlock(),o=a.getCollectionGuaranteesList(),s=a.getBlockSealsList(),c=a.getSignaturesList(),i=we();return i.tag=e.tag,i.block={id:Ne(a.getId_asU8()),parentId:Ne(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:o.map(e=>({collectionId:Ne(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:s.map(e=>({blockId:Ne(e.getBlockId_asU8()),executionReceiptId:Ne(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:c},i}(t,I);case oe(t):return async function(e,t={}){e=await e;const n=new m;n.setHeight(Number(e.block.height));const a=(await be(t.node,r.GetBlockByHeight,n)).getBlock(),o=a.getCollectionGuaranteesList(),s=a.getBlockSealsList(),c=a.getSignaturesList(),i=we();return i.tag=e.tag,i.block={id:xe(a.getId_asU8()),parentId:xe(a.getParentId_asU8()),height:a.getHeight(),timestamp:a.getTimestamp(),collectionGuarantees:o.map(e=>({collectionId:xe(e.getCollectionId_asU8()),signatures:e.getSignaturesList()})),blockSeals:s.map(e=>({blockId:xe(e.getBlockId_asU8()),executionReceiptId:xe(e.getExecutionReceiptId_asU8()),executionReceiptSignatures:e.getExecutionReceiptSignaturesList(),resultApprovalSignatures:e.getResultApprovalSignaturesList()})),signatures:c},i}(t,I);case se(t):return async function(e,t={}){e=await e;const n=new y;await be(t.node,r.Ping,n);let a=we();return a.tag=e.tag,a}(t,I);default:return t}};function Oe(e=null){return pe([W,t=>(t.block.isSealed=e,L(t))])}function Le(e){return pe([z,t=>(t.account.addr=h(e),L(t))])}const _e=async(e,t,n)=>{try{return Number(e)}catch(e){throw new Error("Decode Number Error : "+n.join("."))}},Ue=async e=>e,Ce=async(e,t,n)=>{const a=await e.fields.reduce(async(e,a)=>((e=await e)[a.name]=await De(a.value,t,[...n,a.name]),e),Promise.resolve({})),r=e.id&&Re(t,e.id);return r?await r(a):a},Ke={UInt:_e,Int:_e,UInt8:_e,Int8:_e,UInt16:_e,Int16:_e,UInt32:_e,Int32:_e,UInt64:_e,Int64:_e,UInt128:_e,Int128:_e,UInt256:_e,Int256:_e,Word8:_e,Word16:_e,Word32:_e,Word64:_e,UFix64:Ue,Fix64:Ue,String:Ue,Character:Ue,Bool:Ue,Address:Ue,Void:async()=>null,Optional:async(e,t,n)=>e?await De(e,t,n):null,Reference:async e=>({address:e.address,type:e.type}),Array:async(e,t,n)=>await Promise.all(e.map(e=>new Promise(async a=>a(await De(e,t,[...n,e.type]))))),Dictionary:async(e,t,n)=>await e.reduce(async(e,a)=>((e=await e)[await De(a.key,t,[...n,a.key])]=await De(a.value,t,[...n,a.key]),e),Promise.resolve({})),Event:Ce,Resource:Ce,Struct:Ce},Re=(e,t)=>{const n=Object.keys(e).find(e=>/^\/.*\/$/.test(e)?new RegExp(e.substring(1,e.length-1)).test(t):e===t);return t&&n&&e[n]},De=async(e,t,n)=>{let a=Re(t,e.type);if(!a)throw new Error(`Undefined Decoder Error: ${e.type}@${n.join(".")}`);return await a(e.value,t,n)},Ge=async(e,t={},n=[])=>{let a=v({},Ke,t);return await De(e,a,n)},Pe=async(e,t={})=>{let n=v({},Ke,t);return e.encodedData?await Ge(e.encodedData,n):e.transaction?v({},e.transaction,{events:await Promise.all(e.transaction.events.map(async function(e){return{type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await Ge(e.payload,n)}}))}):e.events?await Promise.all(e.events.map(async function(e){return{type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await Ge(e.payload,n)}})):e.account?e.account:e.block?e.block:e.blockHeader?e.blockHeader:e.latestBlock?(console.error("\n          %c@onflow/decode Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the response object is deprecated and will no longer be recognized in future releases of @onflow/decode.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;"),e.latestBlock):e.transactionId?e.transactionId:null};function je(e){return async t=>Q(t)?(t.message.refBlock||(t.message.refBlock=await async function(e){var t;return t=await pe(T(),[Oe()]),t=await Ee(t,e),(t=await Pe(t)).id}(e)),L(t)):L(t)}const ze=e=>"function"==typeof e,Fe=e=>"string"==typeof e;async function He(n){if(Q(n)||X(n)){var a=me(n,"ix.cadence");t(ze(a)||Fe(a),"Cadence needs to be a function or a string."),ze(a)&&(a=await a({})),t(Fe(a),"Cadence needs to be a string at this point."),n.message.cadence=await e().where(/^0x/).then(e=>Object.entries(e).reduce((e,[t,n])=>e.replace(t,n),a))}return n}const qe=e=>"function"==typeof e;function Je(e){return t(null!=typeof e.xform,"No type specified for argument: "+e.value),qe(e.xform)?e.xform(e.value):qe(e.xform.asArgument)?e.xform.asArgument(e.value):void t(!1,"Invalid Argument",e)}async function $e(e){if(Q(e)||X(e))for(let[t,n]of Object.entries(e.arguments))e.arguments[t].asArgument=Je(n);return e}function We(e,t){try{return{f_type:"PreSignable",f_vsn:"1.0.0",roles:e.role,cadence:t.message.cadence,args:t.message.arguments.map(e=>t.arguments[e].asArgument),data:{},interaction:t}}catch(e){throw console.error("buildPreSignable",e),e}}async function Ye(e,n,a,r=3){t(r,"Account Resolve Recursion Limit Exceeded",{ix:e,accounts:n});let o=[];for(let t of n){var s=a||t;"function"==typeof t.resolve&&(t=await t.resolve(t,We(t,e))),Array.isArray(t)?await Ye(e,t,s,r-1):(e.accounts[t.tempId]=e.accounts[t.tempId]||t,e.accounts[t.tempId].role.proposer=e.accounts[t.tempId].role.proposer||t.role.proposer,e.accounts[t.tempId].role.payer=e.accounts[t.tempId].role.payer||t.role.payer,e.accounts[t.tempId].role.authorizer=e.accounts[t.tempId].role.authorizer||t.role.authorizer,e.accounts[t.tempId].role.proposer&&e.proposer===s.tempId&&(e.proposer=t.tempId),e.accounts[t.tempId].role.payer&&e.payer===s.tempId&&(e.payer=t.tempId),e.accounts[t.tempId].role.authorizer&&(a?o=[...o,t.tempId]:e.authorizations=e.authorizations.map(e=>e===s.tempId?t.tempId:e))),s.tempId!=t.tempId&&delete e.accounts[s.tempId]}a&&(e.authorizations=e.authorizations.map(e=>e===a.tempId?o:e).reduce((e,t)=>Array.isArray(t)?[...e,...t]:[...e,t],[]))}async function Me(e){if(Q(e))try{await Ye(e,Object.values(e.accounts)),await Ye(e,Object.values(e.accounts))}catch(e){throw console.error("=== SAD PANDA ===\n\n",e,"\n\n=== SAD PANDA ==="),e}return e}const Ve=(e,t)=>Buffer.from(e.padStart(2*t,0),"hex"),Xe=e=>Ve(e,8),Qe=e=>Buffer.from(JSON.stringify(e),"utf8"),Ze=e=>Buffer.from(e,"utf8"),et=e=>b(e).toString("hex"),tt=e=>{return rt(e),[Ze(e.script),e.arguments.map(Qe),(t=e.refBlock,Ve(t,32)),e.gasLimit,Xe(e.proposalKey.address),e.proposalKey.keyId,e.proposalKey.sequenceNum,Xe(e.payer),e.authorizers.map(Xe)];var t},nt=e=>{const t=at(e);return e.payloadSigs.map(e=>({signerIndex:t.get(e.address),keyId:e.keyId,sig:e.sig})).sort((e,t)=>e.signerIndex>t.signerIndex?1:e.signerIndex<t.signerIndex?-1:e.keyId>t.keyId?1:e.keyId<t.keyId?-1:void 0).map(e=>{return[e.signerIndex,e.keyId,(t=e.sig,Buffer.from(t,"hex"))];var t})},at=e=>{const t=new Map;let n=0;const a=e=>{t.has(e)||(t.set(e,n),n++)};return a(e.proposalKey.address),a(e.payer),e.authorizers.forEach(a),t},rt=e=>{ut.forEach(t=>pt(e,t)),lt.forEach(t=>pt(e.proposalKey,t,"proposalKey"))},ot=e=>"number"==typeof e,st=e=>"string"==typeof e,ct=e=>null!==e&&"object"==typeof e,it=e=>ct(e)&&e instanceof Array,ut=[{name:"script",check:st},{name:"arguments",check:it},{name:"refBlock",check:st,defaultVal:"0"},{name:"gasLimit",check:ot},{name:"proposalKey",check:ct},{name:"payer",check:st},{name:"authorizers",check:it}],lt=[{name:"address",check:st},{name:"keyId",check:ot},{name:"sequenceNum",check:ot}],dt=[{name:"payloadSigs",check:it}],gt=[{name:"address",check:st},{name:"keyId",check:ot},{name:"sig",check:st}],pt=(e,t,n,a)=>{const{name:r,check:o,defaultVal:s}=t;if(null==e[r]&&null!=s&&(e[r]=s),null==e[r])throw mt(r,n,a);if(!o(e[r]))throw yt(r,n,a)},ft=(e,t,n)=>t?null==n?`${t}.${e}`:`${t}.${n}.${e}`:e,mt=(e,t,n)=>new Error("Missing field "+ft(e,t,n)),yt=(e,t,n)=>new Error("Invalid field "+ft(e,t,n));async function ht(e){if(Q(e))try{let n=function(e){let t=new Set(e.authorizations);return t.add(e.proposer),t.delete(e.payer),Array.from(t)}(e);const a=(t=It(e),et(tt(t)));await Promise.all(n.map(kt(e,a)));let r=function(e){let t=new Set([e.payer]);return Array.from(t)}(e);const o=(e=>et((e=>((e=>{dt.forEach(t=>pt(e,t)),e.payloadSigs.forEach((e,t)=>{gt.forEach(n=>pt(e,n,"payloadSigs",t))})})(e),[tt(e),nt(e)]))(e)))(v({},It(e),{payloadSigs:n.map(t=>({address:e.accounts[t].addr,keyId:e.accounts[t].keyId,sig:e.accounts[t].signature}))}));await Promise.all(r.map(kt(e,o)))}catch(t){throw console.error("Signatures",t,{ix:e}),t}var t;return e}function kt(e,t){return async function(n){const a=e.accounts[n];if(null!=a.signature)return;const{signature:r}=await a.signingFunction(function(e,t,n){try{return{f_type:"Signable",f_vsn:"1.0.0",message:t,addr:h(e.addr),keyId:e.keyId,roles:e.role,cadence:n.message.cadence,args:n.message.arguments.map(e=>n.arguments[e].asArgument),data:{},interaction:n}}catch(e){throw console.error("buildSignable",e),e}}(a,t,e));e.accounts[n].signature=r}}function It(e){return{script:e.message.cadence,refBlock:e.message.refBlock||null,gasLimit:e.message.computeLimit,arguments:e.message.arguments.map(t=>e.arguments[t].asArgument),proposalKey:{address:h(e.accounts[e.proposer].addr),keyId:e.accounts[e.proposer].keyId,sequenceNum:e.accounts[e.proposer].sequenceNum},payer:h(e.accounts[e.payer].addr),authorizers:e.authorizations.map(t=>h(e.accounts[t].addr)).reduce((e,t)=>e.find(e=>e===t)?e:[...e,t],[])}}async function wt(e){const t=me(e,"ix.validators",[]);return pe(e,t.map(e=>t=>e(t,{Ok:L,Bad:_})))}const bt=pe([He,$e,Me,async function(e){return Q(e)&&null==e.message.refBlock&&(e.message.refBlock=(await Ee([Oe()],opts).then(Pe)).id),e},async function(e){if(Q(e)){var n=Object.values(e.accounts).find(e=>e.role.proposer);t(n,"Transactions require a proposer"),null==n.sequenceNum&&(e.accounts[n.tempId].sequenceNum=await Ee(await Ie([Le(n.addr)])).then(Pe).then(e=>e.keys).then(e=>e.find(e=>e.index===n.keyId)).then(e=>e.sequenceNumber))}return e},ht,async function(e){for(let t of Object.keys(e.accounts))e.accounts[t].addr=h(e.accounts[t].addr);return e},wt]),St=async(t=[],n={})=>{const a=await e().get("sdk.send",n.send||Ee),r=await e().get("sdk.resolve",n.resolve||bt);return Array.isArray(t)&&(t=pe(T(),t)),a(await r(t),n)};async function vt(t){const n=await e().where(/^decoder\./),a=Object.entries(n).map(([e,t])=>[e=`/${e.replace(/^decoder\./,"")}$/`,t]);return Pe(t,Object.fromEntries(a))}function Bt(...e){let t=e[1]||("object"==typeof e[0]?e[0]:void 0),n="boolean"==typeof e[0]?e[0]:void 0;return"object"!=typeof e[0]&&console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing options as the first arguement to the latestBlock function has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0007-deprecate-opts-first-arg-latest-block\n  \n      ============================\n    ","font-weight:bold;font-family:monospace;"),St([Oe(n)],t).then(Pe)}function At(e,t){return St([Le(e)],t).then(Pe)}const Tt={authorizer:!0};function Nt(e=[]){return pe(e.map(e=>{return t="function"==typeof e?{resolve:e,role:Tt,roles:Tt}:v({},e,{role:Tt,roles:Tt}),e=>{let n=O();return e.authorizations.push(n),L(pe(e,[C(t,n)]))};var t}))}function xt(e,t,n,a){return{addr:e,signingFunction:t,keyId:n,sequenceNum:a}}function Et(e){return he("ix.validators",t=>Array.isArray(t)?t.push(e):[e])}function Ot(e){return pe([t=>(t.block.height=e,L(t)),Et((e,{Ok:t,Bad:n})=>"boolean"==typeof e.block.isSealed?n(e,"Unable to specify both block height and isSealed."):e.block.id?n(e,"Unable to specify both block height and block id."):t(e))])}function Lt(e){return pe([t=>(t.block.id=e,L(t)),Et((e,{Ok:t,Bad:n})=>te(e)?n(e,"Unable to specify a block id with a Get Account interaction."):"boolean"==typeof e.block.isSealed?n(e,"Unable to specify both block id and isSealed."):e.block.height?n(e,"Unable to specify both block id and block height."):t(e))])}function _t(e,t,n){return void 0===t&&void 0===n||console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing a start and end into getEnvents has been deprecated and will not be supported in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder\n  \n      ============================\n    ","font-weight:bold;font-family:monospace;"),pe([F,a=>(a.events.eventType=e,a.events.start=t,a.events.end=n,L(a))])}function Ut(e,t,n){return pe([F,a=>(a.events.eventType=e,a.events.start=t,a.events.end=n,L(a))])}function Ct(e=[]){return pe([F,t=>(t.events.eventType=eventType,t.events.blockIds=e,L(t))])}function Kt(e=null){return pe([Y,t=>(t.block.isSealed=e,L(t))])}function Rt(e=!1){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getLatestBlock builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0006-deprecate-get-latest-block-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),pe([H,t=>(t.block.isSealed=e,L(t))])}function Dt(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockById builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0004-deprecate-get-block-by-id-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),pe([q,t=>(t.block.ids=[e],L(t))])}function Gt(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockByHeight builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0003-deprecate-get-block-by-height-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),pe([J,t=>(t.block.height=e,L(t))])}function Pt(e){return pe([P,t=>(t.transaction.id=e,L(t))])}function jt(e){return pe([j,t=>(t.transaction.id=e,L(t))])}function zt(e){return pe([t=>(t.message.computeLimit=e,L(t))])}function Ft(e=[]){return pe(e.map(K))}function Ht(e,t=null,n=null){return{key:n,value:e,xform:null}}function qt(e=[]){return pe(e.map(R))}function Jt(e,t){return{value:e,xform:t}}const $t={proposer:!0};async function Wt(e){return t="function"==typeof e?{resolve:e,role:$t,roles:$t}:v({},e,{role:$t,roles:$t}),e=>{let n=O();return e.proposer=n,L(pe(e,[C(t,n)]))};var t}const Yt={payer:!0};function Mt(e){return t="function"==typeof e?{resolve:e,role:Yt,roles:Yt}:v({},e,{role:Yt,roles:Yt}),e=>{let n=O();return e.payer=n,L(pe(e,[C(t,n)]))};var t}function Vt(){return $}function Xt(e){return pe([t=>(t.message.refBlock=e,L(t))])}function Qt(...e){return pe([D,ye("ix.cadence",S(...e))])}const Zt=[];function en(...e){return pe([G,ye("ix.cadence",S(...e)),e=>(e.message.computeLimit=e.message.computeLimit||10,e.message.refBlock=e.message.refBlock||null,e.authorizations=e.authorizations||Zt,L(e))])}function tn(...e){if(e.length>1){const[t,n]=e;return tn((e,{Ok:a,Bad:r})=>t?a(e):r(e,n))}const[t]=e;return e=>t(e,{Ok:L,Bad:_})}function nn(e){return console.error("\n      %cFCL/SDK Deprecation Notice\n      ============================\n\n      The resolver sdk.resolveParams is being replaced with the package @onflow/sdk-resolve-cadence\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0002-deprecate-resolve-params-resolver\n\n      ============================\n    ","font-weight:bold;font-family:monospace;"),He(e)}export{At as account,Jt as arg,qt as args,Ot as atBlockHeight,Lt as atBlockId,xt as authorization,Nt as authorizations,Ie as build,vt as decode,ke as destroy,me as get,Le as getAccount,Oe as getBlock,Gt as getBlockByHeight,Dt as getBlockById,Kt as getBlockHeader,_t as getEvents,Ut as getEventsAtBlockHeightRange,Ct as getEventsAtBlockIds,Rt as getLatestBlock,jt as getTransaction,Pt as getTransactionStatus,T as interaction,tn as invariant,le as isBad,te as isGetAccount,ce as isGetBlock,oe as isGetBlockByHeight,re as isGetBlockById,ie as isGetBlockHeader,ne as isGetEvents,ae as isGetLatestBlock,ee as isGetTransaction,Z as isGetTransactionStatus,ue as isOk,se as isPing,X as isScript,Q as isTransaction,V as isUnknown,Bt as latestBlock,zt as limit,Ht as param,Ft as params,Mt as payer,Vt as ping,pe as pipe,Wt as proposer,ye as put,Xt as ref,bt as resolve,Me as resolveAccounts,$e as resolveArguments,nn as resolveParams,je as resolveRefBlockId,ht as resolveSignatures,wt as resolveValidators,Qt as script,St as send,en as transaction,he as update,Et as validator,de as why};
//# sourceMappingURL=sdk.modern.js.map
